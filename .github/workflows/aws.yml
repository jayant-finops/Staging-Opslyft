name: Production Environment Deployment - Opslyft V2

on:
  push:
    branches:
      - production

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_PREFIX: website/opslyftv2
  SECRET_NAME: website/opslyftv2/.env
  ENVIRONMENT: production
  CLUSTER_NAME: production
  SERVICE_NAME: v2-website-opslyftv2
  # Container selection - you can override this if needed
  MAIN_CONTAINER_NAME: "website_runner"

jobs:
  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    environment: production

    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Extract metadata
        id: meta
        run: |
          # Get branch name, replacing special characters for Docker tag compatibility
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          SAFE_BRANCH_NAME=$(echo "${BRANCH_NAME}" | sed 's/[^a-zA-Z0-9._-]/-/g')
          
          # Get short commit SHA
          SHORT_SHA=${GITHUB_SHA:0:7}
          
          # Set environment
          ENVIRONMENT="${{ env.ENVIRONMENT }}"
          
          # Determine ECR repository
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          ECR_PREFIX=${{ env.ECR_REPOSITORY_PREFIX }}
          ECR_REPOSITORY="${ECR_PREFIX}"
          
          # Set image tags
          TAGS="${ECR_REGISTRY}/${ECR_REPOSITORY}:${SAFE_BRANCH_NAME}-${SHORT_SHA}"
          TAGS="${TAGS},${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
          
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository=${ECR_REPOSITORY}" >> $GITHUB_OUTPUT
          echo "branch=${SAFE_BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          
          # Output for summary
          echo "ðŸŽ¯ **Environment**: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ **ECR Repository**: ${ECR_REPOSITORY}" >> $GITHUB_STEP_SUMMARY
          
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            ENVIRONMENT=${{ steps.meta.outputs.environment }}
            # IMAGE_TAG=${{ steps.meta.outputs.branch }}-${{ steps.meta.outputs.short-sha }}
            # BRANCH_NAME=${{ steps.meta.outputs.branch }}
            # COMMIT_SHA=${{ steps.meta.outputs.short-sha }}
            SECRET_NAME=${{ env.SECRET_NAME }}
            AWS_REGION=${{ env.AWS_REGION }}
          secrets: |
            "aws_access_key_id=${{ env.AWS_ACCESS_KEY_ID }}"
            "aws_secret_access_key=${{ env.AWS_SECRET_ACCESS_KEY }}"
            "aws_session_token=${{ env.AWS_SESSION_TOKEN }}"
          labels: |
            org.opencontainers.image.title=${{ github.repository }}
            org.opencontainers.image.description=Docker image for ${{ github.repository }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.version=${{ steps.meta.outputs.branch }}-${{ steps.meta.outputs.short-sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.licenses=${{ github.event.repository.license.spdx_id }}
            secret.name=${{ env.SECRET_NAME }}
            secret.environment=${{ steps.meta.outputs.environment }}
            created.by=${{ github.actor }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Update ECS Service
        run: |
          
          # Get the current task definition
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "${{ env.CLUSTER_NAME }}" \
            --services "${{ env.SERVICE_NAME }}" \
            --query 'services[0].taskDefinition' \
            --output text)
          
          if [ "$TASK_DEF_ARN" = "None" ]; then
            echo "âŒ Service not found. Please ensure the ECS service exists."
            exit 1
          fi
          
          echo "ðŸ“‹ Current task definition: $TASK_DEF_ARN" >> $GITHUB_STEP_SUMMARY
          
          # Get the current task definition details
          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --query 'taskDefinition' > current-task-def.json
          
          # Find the main application container by name first, then fallback to smart detection
          MAIN_CONTAINER_INDEX=$(jq -r --arg container_name "${{ env.MAIN_CONTAINER_NAME }}" \
            '.containerDefinitions | to_entries | map(select(.value.name == $container_name)) | .[0].key // empty' current-task-def.json)
          
          if [ "$MAIN_CONTAINER_INDEX" = "null" ] || [ -z "$MAIN_CONTAINER_INDEX" ]; then
            echo "âš ï¸  Container '${{ env.MAIN_CONTAINER_NAME }}' not found, trying smart detection..." >> $GITHUB_STEP_SUMMARY
            
            # Smart detection: exclude sidecar containers
            MAIN_CONTAINER_INDEX=$(jq -r '.containerDefinitions | to_entries | map(select(.value.name | test("sidecar|loki|fluent|log|log_router|monitor|agent|proxy|datadog|newrelic|jaeger|zipkin"; "i") | not)) | .[0].key' current-task-def.json)
            
            if [ "$MAIN_CONTAINER_INDEX" = "null" ] || [ -z "$MAIN_CONTAINER_INDEX" ]; then
              echo "âš ï¸  Smart detection failed, using first container as fallback" >> $GITHUB_STEP_SUMMARY
              MAIN_CONTAINER_INDEX=0
            else
              echo "ðŸŽ¯ Found main container via smart detection at index $MAIN_CONTAINER_INDEX" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ðŸŽ¯ Found container '${{ env.MAIN_CONTAINER_NAME }}' at index $MAIN_CONTAINER_INDEX" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Update the container image in the task definition
          jq --arg new_image "${{ steps.meta.outputs.registry }}/${{ steps.meta.outputs.repository }}:${{ steps.meta.outputs.branch }}-${{ steps.meta.outputs.short-sha }}" \
            --argjson index "$MAIN_CONTAINER_INDEX" \
            '.containerDefinitions[$index].image = $new_image' current-task-def.json > updated-task-def.json
          
          # Remove fields that can't be specified when registering a new revision
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' updated-task-def.json > final-task-def.json
          
          # Register new task definition revision
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://final-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "âœ… New task definition created: $NEW_TASK_DEF_ARN" >> $GITHUB_STEP_SUMMARY
          
          # Update the service to use the new task definition
          aws ecs update-service \
            --cluster "${{ env.CLUSTER_NAME }}" \
            --service "${{ env.SERVICE_NAME }}" \
            --task-definition "$NEW_TASK_DEF_ARN"
          
          echo "âœ… ECS service updated successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”„ New task definition: $NEW_TASK_DEF_ARN" >> $GITHUB_STEP_SUMMARY
          
          # Clean up temporary files
          rm -f current-task-def.json updated-task-def.json final-task-def.json

      - name: Wait for service stability
        run: |
          echo "â³ Waiting for service to reach stable state..." >> $GITHUB_STEP_SUMMARY
          
          aws ecs wait services-stable \
            --cluster "${{ env.CLUSTER_NAME }}" \
            --services "${{ env.SERVICE_NAME }}"
          
          echo "âœ… Service is now stable" >> $GITHUB_STEP_SUMMARY

      - name: Summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Summary - Opslyft V2" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ steps.meta.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ steps.meta.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ steps.meta.outputs.short-sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ steps.meta.outputs.registry }}/${{ steps.meta.outputs.repository }}:${{ steps.meta.outputs.branch }}-${{ steps.meta.outputs.short-sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**ECR Repository:** ${{ steps.meta.outputs.repository }}" >> $GITHUB_STEP_SUMMARY
          

          echo "**Created By:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Secret Name:** ${{ env.SECRET_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** This deployment was automatically triggered by a push to the production branch." >> $GITHUB_STEP_SUMMARY 
